#+TITLE: Notes from Learning DDD

* Preface

Stages
1. Strategic design, in which we understand the business problem and
   break the problem down into smaller, solvable, interconnected problems.
2. Tactical design, where we transform the discoveries of strategic
   design into software architecture and implementation.

The book is divided into 4 parts:
- strategic design
- tactical design
- DDD in practice
- DDD's relationships to other methodologies

* Introduction

Most software fails in some way. The author posits that the cause is
communication issues. DDD proposes to attack the root cause through a
framework for effective communication. DDD can be divided into
strategic and tactical:

- The strategic tools of DDD are used to analyze business domains and
  strategy, and to foster a shared understanding of the business
  between the different stakeholders.
  - handles the what and why of the software we are building
- The tactical tools allow us to write code in a way that reflects the
  business domain, address its goals, and speak the language of the
  business.
  - the how, how each component is implemented

* 1. Analyzing Business Domains

This chapter is about learning how companies work: why they exist,
what goals they are pursuing, and their strategies for achieving their
goals. To design and build an effective solution, we have to
understand the problem.

To achieve its business domain's goals and targets, a company has to
operate in multiple subdomains. A *subdomain* is a fine-grained area of
business activity. A single subdomain is not enough for a company to
succeed, there has to be multiple subdomains that interact with each
other to achieve the company's goals in its business domain.

Ask whether the subdomain in question can be turned into a side
business. Would someone pay for it on it's own? If so, this is a core
subdomain.

| Subdomain type | Competitive advantage | Complexity | Volatility | Implementation      | Problem    |
|----------------+-----------------------+------------+------------+---------------------+------------|
| Core           | Yes                   | High       | High       | In-house            | Interesting|
| Generic        | No                    | High       | Low        | Buy/adopt           | Solved     |
| Supporting     | No                    | Low        | Low        | In-house/outsource  | Obvious    |


idea: Conway's law
What would software that runs the entirety of $EMPLOYER look like?

* 2. Discovering Domain Knowledge

Gherkin tests are good ways to make domain oriented scenarios that
define software behavior well

#+begin_text
Feature: Guess the word

  # The first example has two steps
  Scenario: Maker starts a game
    When the Maker starts a game
    Then the Maker waits for a Breaker to join

  # The second example has three steps
  Scenario: Breaker joins a game
    Given the Maker has started a game with the word "silky"
    When the Breaker joins the Maker's game
    Then the Breaker must guess a word with 5 characters
#+end_text

* 3. Managing Domain Complexity

Architectural design is system design. System design is contextual
design -- it is inherently about boundaries (what's in, what's out,
what moves between), and about trade-offs. It reshapes what is
outside, just as it shapes what is inside.

The bounded context pattern is the DDD tool for defining physical and
ownership boundaries.

Bounded contexts decompose a system into physical components—services,
subsystems, and so on. Each bounded context’s lifecycle is decoupled
from the rest. Each bounded context can evolve independently from the
rest of the system. However, the bounded contexts have to work
together to form a system. Some of the changes will inadvertently
affect another bounded context. In the next chapter, we’ll talk about
the different patterns for integrating bounded contexts that can be
used to protect them from cascading changes.

* 4. Integrating Bounded Contexts

Although bounded contexts can evolve independently, they have to
integrate with one another. As a result, there will always be
touchpoints between bounded contexts. These are called /contracts/.

This chapter focuses on defining relationshiops and integrations
between bounded contexts. The book divides these into 3 groups, each
representing a type of team collaboration: cooperation,
customer-supplier, and separate ways.

** Cooperation

Bounded contexts implemented by teams with well-established
communication. This applies to single teams, or teams with dependent
goals. The main criteria is the quality of the teams' communications
and collaboration.

2 DDD patterns suitable for cooperating teams:

*** Partnership

Integration between bounded contexts is coordinated in an ad hoc
manner. One team can notify a second team about a change in the API,
and the second team will cooperate and adapt -- no drama or conflicts.

*** Shared Kernel

A case where the same model of a subdomain, or a part of it, will be
implemented in multiple bounded contexts. The shared model is designed
according to the needs of all it's overlapping bounded contexts, and
each change has to be consistent across each bounded context.

The overarching applicability criterion for the shared kernel pattern
is the cost of duplication vs the cost of coordination.

** Customer-Supplier

The supplier provides a service for its customers. Unlike in
cooperation, both teams can succeed independently. In most cases, we
have an imbalance of power: either the upstream or downstream team can
dictate the integration contract.

3 patterns addressing such power differences:

*** Conformist

balance of power favors the upstream team, which has no real
motivation to support its clients' needs. The supplier offers a
contract according to its own model, and if the downstream team can
accept it the relationship is called conformist.

*** Anticorruption Layer

The consumer is not willing to accept the supplier's model. Instead,
the downstream (customer) translates the supplier's bounded context's
model into a model tailored to its own needs via an anticorruption
layer.

Some reasons this may happen:

- downstream bounded context contains a core subdomain
- upstream model is iniefficient or inconvenient for the customer's needs
- the upstream contract changes often

*** Open-host Service

The case in which the power is skewed toward the consumers. The
supplier is interested in protecting its consumers and providing the
best service possible. To protect consumers from its implementation
model, the upstream supplier decouples the implementation model from
the public interface.

In a sense, this pattern is the opposite of the anticorruption layer
pattern. Instead of the consumer, the supplier implements the
translation of its internal model.

** Separate ways

The last collaboration option is not to collaborate at all.

* 5. Implementing Simple Business Logic

We start with 2 patterns suited for simple business logic: transaction
script and active record.

** Transaction Script

Organizes business logic by procedures where each procedure handles a
single request from the presentation - Martin Fowler

A system's public interface can be seen as a collection of business
transactions that consumers can execute. The pattern organizes the
system's business logic based on procedures, where each procedure
implements an operation that is executed by the system's consumer via
its public interface. In effect, the system's public operations are
used an encapsulation boundaries.

*** Implementation

Each procedure is a straightforward procedural script. The only
requirement procedures have to fulfill is transactional behavior. Each
operation should either succeed or fail, but can never result in an
invalid state.

This is kind of like the unit of work implementation.

** Active Record

An object that wraps a row in a database table or view, encapsulates
the database access, and adds domain logic on that data. - Martin
Fowler

*** Implementation

This pattern uses objects, known as active records, to represent
complicated data structures. It also implements data access methodsw
for CRUD operations. The active record objects are coupled to an ORM
or some other data access framework. The pattern's name is derived
from the fact that each data structure is 'active', i.e. it implements
data access logic.

An active record is essentially a transaction script that optimizes
access to databases.

BUILD: Active Record Implementation
BUILD: Transaction Script Implementation

* 6. Tackling Complex Business Logic

This chapter introduces a pattern oriented for complicated business
logic: the domain model pattern. The pattern is "domain model", and
the aggregates and value objects are its building blocks.

** Domain Model

Instead of CRUD interfaces, we deal with complicated state
transitions, business rules, and invariants: rules that have to be
protected at all times.

*** Implementation

A domain model is an object model of the domain that incorporates both
behavior and data. DDD's tactical patterns -- aggregates, value
objects, domain events, and domain services -- are the building blocks
of such an object model. These all share a common theme: they put the
business logic first.

The model should be devoid of any infrastructural or technological
concerns, such as implementing calls to databases or other external
components of the system.

*** Building Blocks

**** Value object

A value object is an object that can be identified by the composition
of its values. The composition of the fields should be unique.

***** Ubiquitous Language

Relying exclusively on the language's standard library's primitive
data types (strs, ints, dicts, etc) to represent concepts of the
business domain is known as the primitive obsession code smell.

The author suggests that you build a bunch of specific, well-named
data types for inputting values. The validation logic can lie in the
value objects themselves. Most importantly, value objects express the
business domain's concepts: they make the code speak the ubiquitous
language.

**** Entities

An entity is the opposite of a value object. It requires an explicit
identification field to distinguish between the different instances of
the entity.

Contrary to value objects, entities are mutable and expected to
change. Entities are an essential building block of any business
domain.

***** Aggregates

An aggregate is an /entity/: it requires an explicit identification
field and its state is expected to change during an instance's
lifecycle. The goal of the pattern is to protect the consistency of
its data. Since an aggregate's data is mutable, there are implications
and challenges that the pattern has to address to keep its state
consistent at all times.

****** Consistency Enforcement

The aggregate is a consistency enforcement boundary. The aggregate's
logic has to validate all incoming modifications and ensure that
changes do not contradict its business rules. In the implementation,
the consistency is enforced by allowing only the aggregate's business
logic to modify its state. All processes or objects external to the
aggregate are only allowed to read the object's state. Its state can
only be mutated by executing corresponding methods of the aggregate's
public interface.

The state-modifying methods exposed as an aggregate's public interface
are often referred to as commands (as in a "command to do something").

****** Transaction Boundary

Since an aggregate's state can only be modified by its own business
logic, the aggregate also acts as a transactional boundary. All
changes to the aggregate's state should be committed transactionally
as one atomic operation.

Furthermore, no system operation can assume a multi-aggregate
transaction. A change to the aggregate's state can only be committed
individually, one aggregate per database transaction.

****** Hierarchy of Entities

We don't use entites as an independent pattern, only as part of an
aggregate.

BUILD: An example hierarchy of entities / aggregate with a well defined
transactional boundary and aggregate root.

This pattern is named "aggregate" because it aggregates business
entities and value objects that belong to the same transaction
boundary.


#+DOWNLOADED: screenshot @ 2024-04-21 11:57:34
[[file:6._Tackling_Complex_Business_Logic/2024-04-21_11-57-34_screenshot.png]]

****** Domain Events

A domain event is a message describing a significant event that has
occurred in the business domain. The goal of a domain event is to
describe what has happened in the business domain and provide all the
necessary data related to the event.

****** Domain Services

Eventually we encounter business logic that doesn't belong to any
aggregate or value object, or that seems relevant to multiple
aggregates. In such cases, DDD proposes to implement the logic as a
domain service.

A /domain service/ is a stateless object that implements the business
logic. Most of the time, the logic orchestrates calls to various
components of the system to perform some calculation or
analysis. Domain services lend themselves to implementing calculation
logic that requires reading the data of multiple aggregates.

This is not a microservice, SOA, or anything similar -- just a
stateless object used to host business logic.

** Managing Complexity

Eliyahu M. Goldratt says wehn discussing the complexity of a system,
we are interested in evaluating the difficulty of controlling and
predicting the system's behavior. These are reflected by the system's
degrees of freedom. A system's degrees of freedom are the data points
needed to describe its state.

A good rule of thumb is to limit the number of data points something
needs to take to perform its duty.

** Conclusion

The domain model handles complex business logic, and consists of 3
main building blocks:

- Value objects
  - concepts of the domain that can be identified exclusively by their
    values and thus do not require an explicit id field
- Aggregates
  - A hierarchy of entities sharing a transactional boundary. All of
    the data included in an aggregate's boundary has to be strongly
    consistent to implement its business logic.
- Domain Services
  - A stateless object that hosts business logic that doesn't
    naturally belong to the domain model's aggregates or value objects


Value objects describe entities' properties, and entities are bound
together into aggregates.

BUILD: Basic program that uses all 3 (value objects, aggregates,
domain services)

* 7. Modeling the Dimension of Time

The event-sourced domain model pattern is based on the same premise as
the domain model pattern, but the way the aggregates' state is
persisted is different. The event-sourced model uses the event
sourcing pattern to manage the aggregate's states: instead of
persisting an aggregate's state, the model generates domain events
describing each change and uses them as the source of truth for the
aggregate's data.

** Event Sourcing

The event sourcing pattern introduces the dimension of time into the
data model.

here is an example of a data representation in an event-sourced
system:


#+DOWNLOADED: screenshot @ 2024-04-21 12:34:01
[[file:7._Modeling_the_Dimension_of_Time/2024-04-21_12-34-01_screenshot.png]]

** Source of Truth

For the event sourcing pattern to work, all changes to an object's
state should be represented and persisted as events.

*** Event Store

The event store should be an append-only storage. This is essentially
a ledger.

BUILD: An event sourcing system with an event store

** Event-Sourced Domain Model

The original domain model maintains a state representation of its
aggregates and emtis select domain events. The *event-sourced* domain
model uses domain events exclusively for modeling the aggregates'
lifecycles.

Each operation on an event-sourced aggregate follows this script:

- load the aggregate's domain events
- reconstitute a state representation - project the events into a
  state representation that can be used to make business decisions
- execute the aggregate's command to execute the business logic, and
  consequently, produce new domain events
- commit the new domain events to the event store

** Advantages
- time traveling
- deep insight
- audit log
- advanced optimistic concurrency management

** Disadvantages
- learning curve
- evolving the model
- architectural complexity

* 8. Architectural Patterns

This chapter focuses on tactical design decisions in a broader
context: the different ways to orchestrate the interactions and
dependencies between a system's components.

Architectural patterns introduce organizational principles for the
different aspects of a codebase and present clear boundaries between
them: how the business logic is wired to the systems' input, output,
and other infrastructural components.

** Layered architecture


#+DOWNLOADED: screenshot @ 2024-04-21 13:02:43
[[file:8._Architectural_Patterns/2024-04-21_13-02-43_screenshot.png]]

*** Variation

It's common to see the layered architecture pattern also have a
service layer.

#+begin_quote
Defines an application's boundary with a layer of servies that
establishes a set of available operations and coordinates the
application's response in each operation.

- Patterns of Enterprise Application Architecture
#+end_quote


#+DOWNLOADED: screenshot @ 2024-04-21 13:04:30
[[file:8._Architectural_Patterns/2024-04-21_13-04-30_screenshot.png]]

Having an explicit service level has some advantages:

- we can reuse the same service layer to serve multiple public
  interfaces, e.g. a GUI and an API, without duplication of
  orchestration logic
- improved modularity
- further decouples the presentation and business logic layers
- makes it easier to test the business functionality

** Ports & Adapters

#+DOWNLOADED: screenshot @ 2024-04-21 13:09:03
[[file:8._Architectural_Patterns/2024-04-21_13-09-03_screenshot.png]]

The core goal of the ports & adapters architecture (also known as
hexagonal, onion, or clean architecture) is to decouple the system's
business logic from it's infrastructure components. Instead of
referencing and calling the infrastructural components directly, the
business logic layer defines "ports" that have to be implemented by
the infrastructure layer. The infrastructure layer implements
"adapters": concrete implementations of the ports interfaces for
working with different technologies.

** Command-Query Responsibility Segregation

This pattern enables representation of the system's data in multiple
persistent models.

We focus on how CQRS allows the use of multiple storage mechanisms for
representing different models of the system's data.

*** Implementation

There are 2 models (and this pattern separates them):
- the command execution model
  - executes operations that modify the system's state.
  - used to implement business logic, validate rules, and enforce
    invariants
- read models
  - as many models as needed to present data to users or supply
    information to other systems

*** Model Segregation

In the CQRS architecture, the responsibilities of the system's models
are segregated according to their type. A command can only operate on
the strongly consistent command execution model. A query cannot
directly modify any of the system's persisted state -- netierh the
read models nor the command execution model.

The command can -- and in many cases should -- return data.

*** When to use CQRS

The CQRS pattern can be useful for applications that need to work with
the same data in multiple models, potentially stored in different
kinds of databases.

* 9. Communication Patterns
